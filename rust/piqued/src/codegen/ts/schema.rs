use std::path::PathBuf;

use crate::{
    codegen::{
        codegen::{
            CodeGenerationContext, CodeGenerator, ImportResult, QueryContext, SerializationResult,
        },
        utils::{indent_block, to_camel_case},
    },
    query::query::{CompositeType, CustomType, EnumType},
};
use string_builder::Builder;

enum ResolvedType {
    Native(String),
    Import(String),
    Array(Box<ResolvedType>),
}

impl ResolvedType {
    fn _get_imports(&self) -> Vec<String> {
        match self {
            ResolvedType::Native(_) => vec![],
            ResolvedType::Import(path) => vec![path.to_string()],
            ResolvedType::Array(inner) => inner._get_imports(),
        }
    }
}

impl ToString for ResolvedType {
    fn to_string(&self) -> String {
        match self {
            ResolvedType::Native(native) => native.to_string(),
            ResolvedType::Import(import) => import.to_string(),
            ResolvedType::Array(array) => format!("{}[]", array.to_string()),
        }
    }
}

pub struct TSGenerator {}

impl TSGenerator {
    pub fn new() -> Self {
        return TSGenerator {};
    }

    fn resolve_type(&self, ctx: &CodeGenerationContext, type_: &str) -> ResolvedType {
        if ctx.query.custom_types_by_name.contains_key(type_) {
            return ResolvedType::Import(to_camel_case(&type_.to_string(), true));
        }

        if type_.starts_with('_') {
            return ResolvedType::Array(Box::new(self.resolve_type(ctx, &type_[1..])));
        }

        let native_type = match type_ {
            "int4" | "int8" | "float4" | "float8" | "numeric" => "number",
            "text" | "bytea" | "varchar" | "char" | "uuid" => "string",
            "bool" => "boolean",
            "date" | "timestamp" | "time" => "Date",
            "json" | "jsonb" => "any",
            _ => "string",
        };

        return ResolvedType::Native(native_type.to_string());
    }

    fn to_safe_identifier(&self, type_: &String) -> Option<String> {
        let mut chars: Vec<char> = vec![];

        let mut at_start = true;
        for char_ in type_.chars() {
            if char_.is_alphabetic()
                || (char_.is_numeric() && !at_start)
                || char_ == '_'
                || char_ == '$'
            {
                chars.push(char_);
                at_start = false;
            }
        }

        if chars.len() == 0 {
            None
        } else {
            Some(chars.iter().collect())
        }
    }
}

impl CodeGenerator for TSGenerator {
    fn serialize_import(
        &self,
        _ctx: &CodeGenerationContext,
        path: &PathBuf,
        identifiers: &Vec<String>,
    ) -> ImportResult {
        let mut b = Builder::default();
        b.append("import { ");
        b.append(identifiers.join(", "));
        b.append(" } from \"");
        b.append(path.as_path().to_str().unwrap());
        b.append("\";");

        ImportResult {
            generated_code: b.string().unwrap(),
        }
    }

    fn serialize_type_prefix(
        &self,
        _ctx: &CodeGenerationContext,
        _types: &Vec<std::sync::Arc<CustomType>>,
    ) -> Option<String> {
        Some(
            "// This file was generated by pqued.
// You can edit it if you want, but you'll probably be sad
// If you have some changes you want to make, check out the configuration options
// Or file a bug report on our definitely-extant github

"
            .to_string(),
        )
    }

    fn serialize_query_prefix(
        &self,
        _ctx: &CodeGenerationContext,
        _queries: &Vec<crate::codegen::codegen::QueryContext>,
    ) -> Option<String> {
        Some(
            "import { Query, EntityQueries } from \"@piqued/client\";
"
            .to_string(),
        )
    }

    fn serialize_type(
        &self,
        ctx: &CodeGenerationContext,
        type_: &CustomType,
    ) -> SerializationResult {
        match type_ {
            CustomType::Composite(CompositeType { name, fields, .. }) => {
                let identifier = to_camel_case(name, true);
                let mut imports: Vec<String> = vec![];

                let mut b = Builder::default();
                b.append("export interface ");
                b.append((&identifier).as_bytes());
                b.append(" {\n");

                for field in fields {
                    let native_type = self.resolve_type(ctx, &field.type_name);

                    b.append("    \"");
                    b.append(field.name.as_bytes());
                    b.append("\": ");
                    b.append(native_type.to_string());
                    b.append(";\n");

                    imports.push(field.type_name.clone());
                }

                b.append("}");

                SerializationResult {
                    generated_code: b.string().unwrap(),
                    identifier,
                    requires_import: imports,
                }
            }

            CustomType::Enum(EnumType { name, values, .. }) => {
                let identifier = to_camel_case(name, true);

                let mut b = Builder::default();
                b.append("export type ");
                b.append((&identifier).as_bytes());
                b.append(" =\n");

                for value in values {
                    b.append("    | \"");
                    b.append(value.as_bytes());
                    b.append("\"\n");
                }
                b.append("    ;");

                SerializationResult {
                    generated_code: b.string().unwrap(),
                    identifier,
                    requires_import: vec![],
                }
            }
        }
    }

    fn serialize_query(
        &self,
        ctx: &CodeGenerationContext,
        QueryContext(parsed_query, probe_result): &QueryContext,
    ) -> SerializationResult {
        let name = &parsed_query.details.name;

        let identifier = to_camel_case(&name, true);
        let mut imports: Vec<String> = vec![];

        let arg_names = probe_result
            .args
            .iter()
            .enumerate()
            .map(|(i, _arg)| match &parsed_query.details.params {
                Some(param) if param.len() > i => to_camel_case(&param[i], false),
                _ => format!("${}", i),
            })
            .collect::<Vec<String>>();

        let param_names = {
            let comma_separated = arg_names
                .iter()
                .map(|param| format!("        \"{}\",\n", param))
                .collect::<Vec<String>>()
                .join("");

            format!("[\n{}    ]", comma_separated)
        };

        let (input_array_type, input_object_type) = {
            let resolved_types = probe_result
                .args
                .iter()
                .map(|arg| {
                    let type_ = self.resolve_type(ctx, arg);
                    if let ResolvedType::Import(import) = &type_ {
                        imports.push(import.clone());
                    }

                    type_.to_string()
                })
                .zip(arg_names)
                .collect::<Vec<(String, String)>>();

            let array_types = resolved_types
                .iter()
                .enumerate()
                .map(|(i, (type_, param))| {
                    let safe_identifier = self
                        .to_safe_identifier(param)
                        .map_or_else(|| format!("${}", i), |v| v);

                    format!("    {}: {},\n", safe_identifier, type_)
                })
                .collect::<Vec<String>>()
                .join("");

            let object_types = resolved_types
                .iter()
                .map(|(type_, param)| format!("    \"{}\": {},\n", param, type_))
                .collect::<Vec<String>>()
                .join("");

            (
                format!("[\n{}]", array_types),
                format!("{{\n{}}}", object_types),
            )
        };

        let (output_array_type, output_object_type) = {
            let resolved_types = probe_result
                .column_names
                .iter()
                .zip(&probe_result.column_types)
                .map(|(name, type_)| {
                    let resolved = self.resolve_type(ctx, type_);
                    if let ResolvedType::Import(import) = &resolved {
                        imports.push(import.clone());
                    }

                    return (name, resolved.to_string());
                })
                .collect::<Vec<(&String, String)>>();

            let array_types = resolved_types
                .iter()
                .enumerate()
                .map(|(i, (name, type_))| {
                    let safe_identifier = self
                        .to_safe_identifier(name)
                        .map_or_else(|| format!("${}", i), |v| v);

                    format!("    {}: {},\n", safe_identifier, type_)
                })
                .collect::<Vec<String>>()
                .join("");

            let object_types = resolved_types
                .iter()
                .map(|(name, type_)| format!("     \"{}\": {},\n", name, type_))
                .collect::<Vec<String>>()
                .join("");

            (
                format!("[\n{}]", array_types),
                format!("{{\n{}}}", object_types),
            )
        };

        let escaped_query = parsed_query.contents.replace('`', "\\`");

        let mut b = Builder::default();
        b.append(format!("export const {}: Query<{}.InputArray, {}.InputObject, {}.OutputArray, {}.OutputObject> = {{\n", identifier, identifier, identifier, identifier, identifier));
        b.append(format!("    name: \"{}\",\n", name));
        b.append(format!("    query: `{}`,\n", escaped_query));
        b.append(format!("    params: {},\n", param_names));
        b.append("    _brand: undefined as any,\n");
        b.append("};\n\n");

        b.append(format!("export namespace {} {{\n", identifier));
        b.append(indent_block(&format!(
            "export type InputArray = {};\n",
            input_array_type
        )));
        b.append(indent_block(&format!(
            "export type InputObject = {};\n",
            input_object_type
        )));
        b.append(indent_block(&format!(
            "export type OutputArray = {};\n",
            output_array_type
        )));
        b.append(indent_block(&format!(
            "export type OutputObject = {};\n",
            output_object_type
        )));
        b.append("}");

        SerializationResult {
            generated_code: b.string().unwrap(),
            identifier,
            requires_import: imports,
        }
    }

    fn serialize_query_suffix(
        &self,
        _ctx: &CodeGenerationContext,
        queries: &Vec<QueryContext>,
    ) -> Option<String> {
        let mut b = Builder::default();
        b.append("export default EntityQueries({\n");

        for query in queries {
            let name = &query.0.details.name;
            let key = to_camel_case(&name, false);
            let identifier = to_camel_case(&name, true);

            b.append(format!("    \"{}\": {},\n", key, identifier));
        }

        b.append("})");

        Some(b.string().unwrap())
    }

    fn resolve_file_path(&self, _ctx: &CodeGenerationContext, path: &PathBuf) -> String {
        let result = path.clone();
        result.with_extension("ts").to_str().unwrap().to_string()
    }
}
