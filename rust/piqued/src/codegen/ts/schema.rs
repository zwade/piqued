use std::path::PathBuf;

use crate::{
    code_builder::codegen_helper::CodegenHelper,
    codegen::{
        codegen::{
            CodeGenerationContext, CodeGenerator, ImportResult, QueryContext, SerializationResult,
        },
        utils::{indent_block, to_camel_case},
    },
    query::query::{CompositeType, CustomType, EnumType},
};
use string_builder::Builder;

enum ResolvedType {
    Native(String),
    Import(String),
    Array(Box<ResolvedType>),
}

impl ResolvedType {
    fn _get_imports(&self) -> Vec<String> {
        match self {
            ResolvedType::Native(_) => vec![],
            ResolvedType::Import(path) => vec![path.to_string()],
            ResolvedType::Array(inner) => inner._get_imports(),
        }
    }

    pub fn get_type(&self) -> String {
        match self {
            ResolvedType::Native(val) => val.to_string(),
            ResolvedType::Import(val) => format!("{}.t", val.to_string()),
            ResolvedType::Array(inner) => format!("{}[]", inner.get_type()),
        }
    }

    pub fn get_spec(&self) -> String {
        match self {
            ResolvedType::Native(val) if val == "number" => "Number".to_string(),
            ResolvedType::Native(val) if val == "string" => "String".to_string(),
            ResolvedType::Native(val) if val == "boolean" => "Boolean".to_string(),
            ResolvedType::Native(val) if val == "Date" => "Date".to_string(),
            ResolvedType::Native(val) if val == "any" => "Object".to_string(),
            ResolvedType::Native(_) => "String".to_string(),
            ResolvedType::Import(val) => format!("{}.spec", val.to_string()),
            ResolvedType::Array(inner) => {
                format!("{{ \"kind\": \"array\", \"spec\": {} }}", inner.get_spec())
            }
        }
    }

    pub fn is_ultimately_custom_type(&self) -> bool {
        match self {
            ResolvedType::Native(_) => false,
            ResolvedType::Import(_) => true,
            ResolvedType::Array(inner) => inner.is_ultimately_custom_type(),
        }
    }
}

impl ToString for ResolvedType {
    fn to_string(&self) -> String {
        match self {
            ResolvedType::Native(native) => native.to_string(),
            ResolvedType::Import(import) => import.to_string(),
            ResolvedType::Array(array) => format!("{}[]", array.to_string()),
        }
    }
}

pub struct TSGenerator {}

impl TSGenerator {
    pub fn new() -> Self {
        return TSGenerator {};
    }

    fn resolve_type(&self, ctx: &CodeGenerationContext, type_: &str) -> ResolvedType {
        if ctx.query.custom_types_by_name.contains_key(type_) {
            return ResolvedType::Import(to_camel_case(&type_.to_string(), true));
        }

        if type_.starts_with('_') {
            return ResolvedType::Array(Box::new(self.resolve_type(ctx, &type_[1..])));
        }

        let native_type = match type_ {
            "int4" | "int8" | "float4" | "float8" | "numeric" => "number",
            "text" | "bytea" | "varchar" | "char" | "uuid" => "string",
            "bool" => "boolean",
            "date" | "timestamp" | "time" | "timestamptz" => "Date",
            "json" | "jsonb" => "any",
            _ => "string",
        };

        return ResolvedType::Native(native_type.to_string());
    }

    fn to_safe_identifier(&self, type_: &String) -> Option<String> {
        let mut chars: Vec<char> = vec![];

        let mut at_start = true;
        for char_ in type_.chars() {
            if char_.is_alphabetic()
                || (char_.is_numeric() && !at_start)
                || char_ == '_'
                || char_ == '$'
            {
                chars.push(char_);
                at_start = false;
            }
        }

        if chars.len() == 0 {
            None
        } else {
            Some(chars.iter().collect())
        }
    }
}

impl CodeGenerator for TSGenerator {
    fn serialize_import(
        &self,
        ctx: &CodeGenerationContext,
        path: &PathBuf,
        identifiers: &Vec<String>,
    ) -> ImportResult {
        let mut b = Builder::default();
        b.append("import { ");
        b.append(identifiers.join(", "));
        b.append(" } from \"");
        b.append(path.as_path().to_str().unwrap());

        if ctx.config.emit.module_type.to_lowercase() == "esm" {
            b.append(".js");
        }

        b.append("\";");

        ImportResult {
            generated_code: b.string().unwrap(),
        }
    }

    fn serialize_type_prefix(
        &self,
        _ctx: &CodeGenerationContext,
        _types: &Vec<std::sync::Arc<CustomType>>,
    ) -> Option<String> {
        Some(
            "// This file was generated by piqued.
// You can edit it if you want, but you'll probably be sad
// If you have some changes you want to make, check out the configuration options
// Or file a bug report on our definitely-extant github

"
            .to_string(),
        )
    }

    fn serialize_query_prefix(
        &self,
        _ctx: &CodeGenerationContext,
        _queries: &Vec<crate::codegen::codegen::QueryContext>,
    ) -> Option<String> {
        Some(
            "import { Query, EntityQueries } from \"@piqued/client\";
"
            .to_string(),
        )
    }

    fn serialize_type(
        &self,
        ctx: &CodeGenerationContext,
        type_: &CustomType,
    ) -> SerializationResult {
        match type_ {
            CustomType::Composite(CompositeType { name, fields, .. }) => {
                let mut c = CodegenHelper::new("    ", "\n");

                let identifier = to_camel_case(name, true);
                let mut imports: Vec<String> = vec![];

                c.write_token("export namespace");
                c.write_token(&identifier);
                c.write_line(Some(&"{"));
                c.with_indent(|c| {
                    c.write_line(Some(&"export type t = {"));
                    c.with_indent(|c| {
                        for field in fields {
                            let native_type = self.resolve_type(ctx, &field.type_name);

                            c.with_duouble_quote(|c| c.write(&field.name));
                            c.write_symbol(": ");
                            c.write(&&native_type.get_type());
                            c.write_symbol(";");
                            c.write_line(None);

                            imports.push(field.type_name.clone());
                        }
                    });
                    c.write_line(Some(&"};"));

                    c.write_line(None);

                    c.write_line(Some(&"export const spec = {"));
                    c.with_indent(|c| {
                        c.write_line(Some(&"kind: \"composite\" as const,"));
                        c.write_line(Some(&"fields: () => ["));
                        c.with_indent(|c| {
                            for field in fields {
                                let native_type = self.resolve_type(ctx, &field.type_name);

                                c.write_symbol("[");
                                c.with_duouble_quote(|c| c.write(&field.name));
                                c.write_symbol(", ");
                                c.write(&&native_type.get_spec());
                                c.write_symbol("],");
                                c.write_line(None);

                                imports.push(field.type_name.clone());
                            }
                        });
                        c.write_line(Some(&"] as const,"));
                    });
                    c.write_line(Some(&"};"));
                });

                c.write_symbol("}");

                SerializationResult {
                    generated_code: c.serialize(),
                    identifier,
                    requires_import: imports,
                }
            }

            CustomType::Enum(EnumType { name, values, .. }) => {
                let mut c = CodegenHelper::new("    ", "\n");

                let identifier = to_camel_case(name, true);

                c.write_token(&"export namespace");
                c.write_token(&identifier);
                c.write_line(Some(&"{"));

                c.with_indent(|c| {
                    c.write_line(Some(&"export type t ="));
                    c.with_indent(|c| {
                        for value in values {
                            c.write(&"| ");
                            c.with_duouble_quote(|c| c.write(&value));
                            c.write_line(None);
                        }
                        c.write(&";");
                        c.write_line(None);
                    });

                    c.write_line(None);

                    c.write_line(Some(&"export const spec = {"));
                    c.with_indent(|c| {
                        c.write_line(Some(&"kind: \"enum\" as const,"));
                        c.write_line(Some(&"values: ["));

                        c.with_indent(|c| {
                            for value in values {
                                c.with_duouble_quote(|c| c.write(&value));
                                c.write_symbol(",");
                                c.write_line(None);
                            }
                        });

                        c.write_line(Some(&"] as const,"));
                    });
                    c.write_line(Some(&"};"));
                });

                c.write_line(Some(&"}"));

                SerializationResult {
                    generated_code: c.serialize(),
                    identifier,
                    requires_import: vec![],
                }
            }
        }
    }

    fn serialize_query(
        &self,
        ctx: &CodeGenerationContext,
        QueryContext(parsed_query, probe_result): &QueryContext,
    ) -> SerializationResult {
        let name = &parsed_query.details.name;

        let identifier = to_camel_case(&name, true);
        let mut imports: Vec<String> = vec![];

        let arg_names = probe_result
            .args
            .iter()
            .enumerate()
            .map(|(i, _arg)| match &parsed_query.details.params {
                Some(param) if param.len() > i => to_camel_case(&param[i], false),
                _ => format!("${}", i),
            })
            .collect::<Vec<String>>();

        let param_names = {
            let comma_separated = arg_names
                .iter()
                .map(|param| format!("        \"{}\",\n", param))
                .collect::<Vec<String>>()
                .join("");

            format!("[\n{}    ]", comma_separated)
        };

        let (input_array_type, input_object_type) = {
            let resolved_types = probe_result
                .args
                .iter()
                .map(|arg| {
                    let type_ = self.resolve_type(ctx, arg);
                    if let ResolvedType::Import(import) = &type_ {
                        imports.push(import.clone());
                    }

                    type_.get_type()
                })
                .zip(arg_names)
                .collect::<Vec<(String, String)>>();

            let array_types = resolved_types
                .iter()
                .enumerate()
                .map(|(i, (type_, param))| {
                    let safe_identifier = self
                        .to_safe_identifier(param)
                        .map_or_else(|| format!("${}", i), |v| v);

                    format!("    {}: {},\n", safe_identifier, type_)
                })
                .collect::<Vec<String>>()
                .join("");

            let object_types = resolved_types
                .iter()
                .map(|(type_, param)| format!("    \"{}\": {},\n", param, type_))
                .collect::<Vec<String>>()
                .join("");

            (
                format!("[\n{}]", array_types),
                format!("{{\n{}}}", object_types),
            )
        };

        let (output_array_type, output_object_type) = {
            let resolved_types = probe_result
                .column_names
                .iter()
                .zip(&probe_result.column_types)
                .map(|(name, type_)| {
                    let resolved = self.resolve_type(ctx, type_);
                    if let ResolvedType::Import(import) = &resolved {
                        imports.push(import.clone());
                    }

                    return (name, resolved.get_type());
                })
                .collect::<Vec<(&String, String)>>();

            let array_types = resolved_types
                .iter()
                .enumerate()
                .map(|(i, (name, type_))| {
                    let safe_identifier = self
                        .to_safe_identifier(name)
                        .map_or_else(|| format!("${}", i), |v| v);

                    format!("    {}: {},\n", safe_identifier, type_)
                })
                .collect::<Vec<String>>()
                .join("");

            let object_types = resolved_types
                .iter()
                .map(|(name, type_)| format!("    \"{}\": {},\n", name, type_))
                .collect::<Vec<String>>()
                .join("");

            (
                format!("[\n{}]", array_types),
                format!("{{\n{}}}", object_types),
            )
        };

        let parse_spec = {
            let resolved_types = probe_result
                .column_names
                .iter()
                .zip(&probe_result.column_types)
                .map(|(name, type_)| {
                    let resolved = self.resolve_type(ctx, type_);
                    match &resolved {
                        ResolvedType::Array(inner) if inner.is_ultimately_custom_type() => {
                            imports.append(&mut resolved._get_imports());
                            (name, resolved.get_spec())
                        }
                        ResolvedType::Import(_) => {
                            imports.append(&mut resolved._get_imports());
                            (name, resolved.get_spec())
                        }
                        _ => (name, "undefined".to_string()),
                    }
                })
                .collect::<Vec<(&String, String)>>();

            let additional_spec = resolved_types
                .iter()
                .map(|(name, spec)| format!("        [\"{}\", {}],\n", name, spec))
                .collect::<Vec<String>>()
                .join("");

            format!("[\n{}    ]", additional_spec)
        };

        let escaped_query = parsed_query.contents.replace('`', "\\`");

        let mut b = Builder::default();
        b.append(format!("export const {}: Query<{}.InputArray, {}.InputObject, {}.OutputArray, {}.OutputObject> = {{\n", identifier, identifier, identifier, identifier, identifier));
        b.append(format!("    name: \"{}\",\n", name));
        b.append(format!("    query: `{}`,\n", escaped_query));
        b.append(format!("    params: {},\n", param_names));
        b.append(format!("    spec: {},\n", parse_spec));
        b.append("    _brand: undefined as any,\n");
        b.append("};\n\n");

        b.append(format!("export namespace {} {{\n", identifier));
        b.append(indent_block(
            &format!("export type InputArray = {};\n", input_array_type),
            1,
        ));
        b.append(indent_block(
            &format!("export type InputObject = {};\n", input_object_type),
            1,
        ));
        b.append(indent_block(
            &format!("export type OutputArray = {};\n", output_array_type),
            1,
        ));
        b.append(indent_block(
            &format!("export type OutputObject = {};\n", output_object_type),
            1,
        ));
        b.append("}");

        SerializationResult {
            generated_code: b.string().unwrap(),
            identifier,
            requires_import: imports,
        }
    }

    fn serialize_query_suffix(
        &self,
        _ctx: &CodeGenerationContext,
        queries: &Vec<QueryContext>,
    ) -> Option<String> {
        let mut b = Builder::default();
        b.append("export default EntityQueries({\n");

        for query in queries {
            let name = &query.0.details.name;
            let key = to_camel_case(&name, false);
            let identifier = to_camel_case(&name, true);

            b.append(format!("    \"{}\": {},\n", key, identifier));
        }

        b.append("})");

        Some(b.string().unwrap())
    }

    fn serialize_table_prefix(
        &self,
        _ctx: &CodeGenerationContext,
        _tables: &Vec<&String>,
    ) -> Option<String> {
        Some("import { TableBuilder } from \"@piqued/client\";\n".to_string())
    }

    fn serialize_table(&self, _ctx: &CodeGenerationContext, table: &String) -> SerializationResult {
        let mut c = CodegenHelper::new("    ", "\n");

        let class_name = to_camel_case(&table, true);
        let export_name = format!("{}Table", &class_name);

        c.write_token("export const");
        c.write_token(&export_name);
        c.write_token("=");
        c.write_line(Some(&format!(
            "new TableBuilder<typeof {}.spec, {}.t, \"{}\">(\"{}\", {}.spec);",
            &class_name, &class_name, &table, &table, &class_name
        )));

        return SerializationResult {
            generated_code: c.serialize(),
            identifier: export_name.clone(),
            requires_import: vec![class_name.clone()],
        };
    }

    fn resolve_file_path(&self, _ctx: &CodeGenerationContext, path: &PathBuf) -> String {
        let result = path.clone();
        result.with_extension("ts").to_str().unwrap().to_string()
    }
}
