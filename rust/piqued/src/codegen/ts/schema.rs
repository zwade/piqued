use std::path::PathBuf;

use crate::{codegen::{codegen::{CodeGenerator, SerializationResult, ImportResult, CodeGenerationContext}, utils::to_camel_case}, query::query::{CustomType, CompositeType, EnumType, ProbeResponse}, parser::parser::ParsedPreparedQuery};
use string_builder::Builder;

enum ResolvedType {
    Native(String),
    Import(String),
    Array(Box<ResolvedType>),
}

impl ResolvedType {
    fn get_imports(&self) -> Vec<String> {
        match self {
            ResolvedType::Native(_) => vec![],
            ResolvedType::Import(path) => vec![path.to_string()],
            ResolvedType::Array(inner) => inner.get_imports(),
        }
    }
}

impl ToString for ResolvedType {
    fn to_string(&self) -> String {
        match self {
            ResolvedType::Native(native) => native.to_string(),
            ResolvedType::Import(import) => import.to_string(),
            ResolvedType::Array(array) => format!("{}[]", array.to_string()),
        }
    }
}

pub struct TSGenerator {}

impl TSGenerator {
    pub fn new() -> Self {
        return TSGenerator {  }
    }

    fn resolve_type(&self, ctx: &CodeGenerationContext, type_: &str) -> ResolvedType {
        if ctx.query.custom_types_by_name.contains_key(type_) {
            return ResolvedType::Import(to_camel_case(&type_.to_string(), true));
        }

        if type_.starts_with('_') {
            return ResolvedType::Array(Box::new(self.resolve_type(ctx, &type_[1..])));
        }

        let native_type = match type_ {
            "int4" | "int8" | "float4" | "float8" | "numeric" => "number",
            "text" | "bytea" | "varchar" | "char" | "uuid" => "string",
            "bool" => "boolean",
            "date" | "timestamp" | "time" => "Date",
            "json" | "jsonb" => "any",
            _ => "string",
        };

        return ResolvedType::Native(native_type.to_string());
    }
}

impl CodeGenerator for TSGenerator {
    fn serialize_import(&self, _ctx: &CodeGenerationContext, path: &PathBuf, identifiers: &Vec<String>) -> ImportResult {
        let mut b = Builder::default();
        b.append("import { ");
        b.append(identifiers.join(", "));
        b.append(" } from \"");
        b.append(path.as_path().to_str().unwrap());
        b.append("\";");

        ImportResult { generated_code: b.string().unwrap() }
    }

    fn serialize_preamble(&self, _ctx: &CodeGenerationContext) -> String {
        let preamble = "
// This file was generated by pqued.
// You can edit it if you want, but you'll probably be sad
// If you have some changes you want to make, check out the configuration options
// Or file a bug report on our definitely-extant github

export type Query<Input extends any[], Output> = {
    name: string;
    query: string;

    _brand: { input: Input, output: Output };
};
";

        return preamble.to_string();
    }

    fn serialize_type(&self, ctx: &CodeGenerationContext, type_: &CustomType) -> SerializationResult {
        match type_ {
            CustomType::Composite(CompositeType { name, fields , .. }) => {
                let identifier = to_camel_case(name, true);
                let mut imports: Vec<String> = vec![];

                let mut b = Builder::default();
                b.append("export interface ");
                b.append((&identifier).as_bytes());
                b.append(" {\n");

                for field in fields {
                    let native_type = self.resolve_type(ctx, &field.type_name);

                    b.append("    \"");
                    b.append(field.name.as_bytes());
                    b.append("\": ");
                    b.append(native_type.to_string());
                    b.append(";\n");

                    imports.push(field.type_name.clone());
                }

                b.append("}");

                SerializationResult {
                    generated_code: b.string().unwrap(),
                    identifier,
                    requires_import: imports,
                }
            },

            CustomType::Enum(EnumType { name, values, .. }) => {
                let identifier = to_camel_case(name, true);

                let mut b = Builder::default();
                b.append("export type ");
                b.append((&identifier).as_bytes());
                b.append(" =\n");

                for value in values {
                    b.append("    | \"");
                    b.append(value.as_bytes());
                    b.append("\"\n");
                }
                b.append("    ;");

                SerializationResult {
                    generated_code: b.string().unwrap(),
                    identifier,
                    requires_import: vec![],
                }
            },
        }
    }

    fn serialize_query(&self, ctx: &CodeGenerationContext, parsed_query: &ParsedPreparedQuery, probe_result: &ProbeResponse) -> SerializationResult {
        let default_name = "query".to_string();
        let name =
            parsed_query
                .details
                .name
                .as_ref()
                .map_or_else(
                    || &default_name,
                    |name| name
                );

        let identifier = to_camel_case(&name, true);
        let mut imports: Vec<String> = vec!["Query".to_string()];

        let input_type_arg = {
            let comma_separated = probe_result.args
                .iter()
                .map(|arg| {
                    let type_ = self.resolve_type(ctx, arg);
                    if let ResolvedType::Import(import) = &type_ {
                        imports.push(import.clone());
                    }

                    type_.to_string()
                })
                .collect::<Vec<String>>()
                .join(", ");

            format!("[{}]", comma_separated)
        };

        let result_type = {
            let comma_separated_obj =
                probe_result.column_names
                    .iter()
                    .zip(&probe_result.column_types)
                    .map(|(name, type_)| {
                        let resolved = self.resolve_type(ctx, type_);
                        if let ResolvedType::Import(import) = &resolved {
                            imports.push(import.clone());
                        }

                        format!("        \"{}\": {},\n", name, resolved.to_string())
                    })
                    .collect::<Vec<String>>()
                    .join("");

            let comma_separated_array =
                probe_result.column_types
                    .iter()
                    .map(|type_| {
                        let resolved = self.resolve_type(ctx, type_);
                        if let ResolvedType::Import(import) = &resolved {
                            imports.push(import.clone());
                        }

                        format!("        {},\n", resolved.to_string())
                    })
                    .collect::<Vec<String>>()
                    .join("");

            format!("{{\n{}    }} & [\n{}    ]", comma_separated_obj, comma_separated_array)
        };

        let mut b = Builder::default();
        b.append(format!("export const {}: Query<{}.Input, {}.Result> = {{\n", identifier, identifier, identifier));
        b.append(format!("    name: \"{}\",\n", name));
        b.append(format!("    query: `{}`,\n", parsed_query.contents));
        b.append(        "    _brand: undefined as any,\n");
        b.append(        "};\n\n");
        b.append(format!("export namespace {} {{\n", identifier));
        b.append(format!("    export type Input = {};\n", input_type_arg));
        b.append(format!("    export type Result = {};\n", result_type));
        b.append(        "}");

        SerializationResult {
            generated_code: b.string().unwrap(),
            identifier,
            requires_import: imports,
        }
    }

    fn resolve_file_path(&self, _ctx: &CodeGenerationContext, path: &PathBuf) -> String {
        let result = path.clone();
        result.with_extension("ts").to_str().unwrap().to_string()
    }
}